import Colors from"./colors";import Utils from"./utils";let X=0,Y=1,V=2,Y2=3,RX=4,RY=5,L=0,T=1,R=2,B=3,ONE_HOUR=36e5;export default class SparklineGraph{constructor(t,a,i,s,r=[],h=[],e={}){this.aggregateFuncMap={avg:this._average,median:this._median,max:this._maximum,min:this._minimum,first:this._first,last:this._last,sum:this._sum,delta:this._delta,diff:this._diff},this.config=s,this.graphArea={},this.graphArea.x=0,this.graphArea.y=0,this.graphArea.width=t-2*this.graphArea.x,this.graphArea.height=a-2*this.graphArea.y,this.drawArea={},this.drawArea.x=i.l,this.drawArea.y=i.t,this.drawArea.top=i.t,this.drawArea.bottom=i.b,this.drawArea.width=t-(i.l+i.r),this.drawArea.height=a-(i.t+i.b),this._history=void 0,this.coords=[],this.width=t,this.height=a,this.margin=i,this._max=0,this._min=0,this.points=this.config.period?.calendar?.bins?.per_hour||this.config.period?.rolling_window?.bins?.per_hour||1,this.hours=this.config.period?.calendar?.duration?.hour||this.config.period?.rolling_window?.duration?.hour||24,this.aggregateFuncName=this.config.sparkline.state_values.aggregate_func,this._calcPoint=this.aggregateFuncMap[this.aggregateFuncName]||this._average,this._smoothing=this.config.sparkline.state_values?.smoothing,this._logarithmic=this.config.sparkline.state_values?.logarithmic,this._groupBy=this.config.period.groupBy,this._endTime=0,this.valuesPerBucket=0,this.levelCount=1,this.gradeValues=r,this.gradeRanks=h,this.stateMap={...e},this.radialBarcodeSize=Utils.calculateSvgDimension(this.config.sparkline?.radial_barcode?.size||5)}get max(){return this._max}set max(t){this._max=t}get min(){return this._min}set min(t){this._min=t}set history(t){this._history=t}update(t=void 0){if(t&&(this._history=t),this._history&&0!==this._history?.length){this._updateEndTime();var i,s,r=new Date,t=(r.getDate(),this.offsetHours=0,"day"===this.config.period?.calendar?.period&&(r.getHours(),r.getMinutes(),r.getSeconds(),this.offsetHours=Math.abs(24*this.config.period.calendar.offset)),this._history.reduce((t,a)=>this._reducer(t,a),[]));t[0]&&t[0].length&&(t[0]=[t[0][t[0].length-1]]);let a;switch(this.offsetHours=0,this.config.period.type){case"real_time":a=1,this.hours=1;break;case"calendar":if("day"===this.config.period?.calendar?.period){let t=this.hours;0===this.config.period.calendar.offset?t=r.getHours()+r.getMinutes()/60:this.offsetHours=Math.abs(24*this.config.period.calendar.offset),a=Math.ceil(t*this.points)}break;case"rolling_window":a=Math.ceil(this.hours*this.points)}t.length=a;try{this.coords=this._calcPoints(t)}catch(t){console.log("error in calcpoints")}this.min=Math.min(...this.coords.map(t=>Number(t[V]))),this.max=Math.max(...this.coords.map(t=>Number(t[V]))),!["line","area"].includes(this.config.sparkline.show.chart_type)||!0!==this.config.sparkline.line?.show_minmax&&!0!==this.config.sparkline.area?.show_minmax||((i=this._history.reduce((t,a)=>this._reducerMinMax(t,a),[]))[0][0]&&i[0][0].length&&(i[0][0]=[i[0][0][i[0][0].length-1]]),i[1][0]&&i[1][0].length&&(i[1][0]=[i[1][0][i[1][0].length-1]]),i[0].length=a,i[1].length=a,i=[...t],t=[...t],s=this._calcPoint,this._calcPoint=this.aggregateFuncMap.min,this.coordsMin=[],this.coordsMin=this._calcPoints(i),this._calcPoint=this.aggregateFuncMap.max,this.coordsMax=[],this.coordsMax=this._calcPoints(t),this._calcPoint=s,this.min=Math.min(...this.coordsMin.map(t=>Number(t[V]))),this.max=Math.max(...this.coordsMax.map(t=>Number(t[V]))))}}_reducerMinMax(t,a){var i=(this._endTime-new Date(a.last_changed).getTime())/ONE_HOUR*this.points-this.hours*this.points,i=i<0?Math.floor(Math.abs(i)):0;return t[0]||(t[0]=[]),t[1]||(t[1]=[]),t[0][i]||(t[0][i]={},t[1][i]={}),t[0][i].state=Math.min(t[0][i].state||Number.POSITIVE_INFINITY,a.state),t[0][i].haState=Math.min(t[0][i].haState||Number.POSITIVE_INFINITY,a.haState),t[1][i].state=Math.max(t[1][i].state?t[0][i].state:Number.NEGATIVE_INFINITY,a.state),t[1][i].haState=Math.max(t[1][i].haState?t[0][i].haState:Number.NEGATIVE_INFINITY,a.haState),t}_reducer(t,a){var i="day"===this.config.period?.calendar?.period?0===this.config.period.calendar.offset?(new Date).getHours()+(new Date).getMinutes()/60:24:this.hours,i=(this._endTime-new Date(a.last_changed).getTime())/ONE_HOUR*this.points-i*this.points,i=i<0?Math.floor(Math.abs(i)):0;return t[i]||(t[i]=[]),t[i].push(a),t}_calcPoints(a){let i=[],s=this.drawArea.width/(this.hours*this.points-1);s=Number.isFinite(s)?s:this.drawArea.width;var t=a.filter(Boolean)[0];let r=[this._calcPoint(t),this._lastValue(t)];var h=(t,a)=>{a=s*a+this.drawArea.x;return t&&(r=[this._calcPoint(t),this._lastValue(t)]),i.push([a,0,t?r[0]:r[1]])};for(let t=0;t<a.length;t+=1)h(a[t],t);return i}_calcY(t){var a=this._logarithmic?Math.log10(Math.max(1,this.max)):this.max;let s=this._logarithmic?Math.log10(Math.max(1,this.min)):this.min,r=(a-s)/this.drawArea.height||1;return t.map(t=>{var a=this._logarithmic?Math.log10(Math.max(1,t[V])):t[V],i=s<0?Math.abs(s):0,i=(0<a&&Math.max(0,s),this.drawArea.height,this.drawArea.y,r,0<a?this.drawArea.height+ +this.drawArea.top-i/r-(a-Math.max(0,s))/r:this.drawArea.height+ +this.drawArea.top-(0-s)/r),a=this.drawArea.height+ +this.drawArea.y-(a-s)/r;return[t[X],a,t[V],i]})}_calcLevelY(t){var a=this._logarithmic?Math.log10(Math.max(1,this.max)):this.max;let i=this._logarithmic?Math.log10(Math.max(1,this.min)):this.min,s=(a-i)/this.drawArea.height||1,r=i<0?Math.abs(i):0,h=[];t[V].forEach((t,a)=>{t=0<=t?this.drawArea.height+ +this.drawArea.top-+r/s-(t-Math.max(0,i))/s:this.drawArea.height+ +this.drawArea.top-(0-t)/s;return h.push(t),h});return h}getPoints(){let t=this.coords;1===t.length&&(t[1]=[this.width+this.margin.x,0,t[0][V]]),t=this._calcY(this.coords);let i,s,r=t[0];return t.shift(),t.map((t,a)=>{i=t,s=this._smoothing?this._midPoint(r[X],r[Y],i[X],i[Y]):i;t=this._smoothing?(i[V]+r[V])/2:i[V];return r=i,[s[X],s[Y],t,a+1]})}getPath(){let t=this.coords;1===t.length&&(t[1]=[this.width+this.margin.x,0,t[0][V]]),t=this._calcY(this.coords);let a,i,s="",r=t[0];return s+=`M${r[X]},`+r[Y],t.forEach(t=>{a=t,i=this._smoothing?this._midPoint(r[X],r[Y],a[X],a[Y]):a,s=(s+=` ${i[X]},`+i[Y])+` Q ${a[X]},`+a[Y],r=a}),s+=` ${a[X]},`+a[Y]}getPathMin(){let t=this.coordsMin;1===t.length&&(t[1]=[this.width+this.margin.x,0,t[0][V]]),t=this._calcY(this.coordsMin);let a,i,s="",r=t[0];return s+=`M${r[X]},`+r[Y],t.forEach(t=>{a=t,i=a,s=(s+=` ${i[X]},`+i[Y])+` Q ${a[X]},`+a[Y],r=a}),s+=` ${a[X]},`+a[Y]}getPathMax(){let t=this.coordsMax;1===t.length&&(t[1]=[this.width+this.margin.x,0,t[0][V]]),t=this._calcY(this.coordsMax);let s,r,h="",e=t[t.length-1];return t.reverse().forEach((t,a,i)=>{s=t,r=s,h=(h+=` ${r[X]},`+r[Y])+` Q ${s[X]},`+s[Y],e=s}),h=(h+=` ${s[X]},`+s[Y])+(`M${e[X]},`+e[Y])}computeGradient(t,e){let o=e?Math.log10(Math.max(1,this._max))-Math.log10(Math.max(1,this._min)):this._max-this._min,n=o/(this.graphArea.height-this.margin.b)*this.graphArea.height-o;return t.map((t,a,i)=>{let s;var r;t.value>this._max&&i[a+1]?(r=(this._max-i[a+1].value)/(t.value-i[a+1].value),s=Colors.getGradientValue(i[a+1].color,t.color,r)):t.value<this._min&&i[a-1]&&(r=(i[a-1].value-this._min)/(i[a-1].value-t.value),s=Colors.getGradientValue(i[a-1].color,t.color,r));let h;return h=o<=0?0:e?(Math.log10(Math.max(1,this._max))-Math.log10(Math.max(1,t.value)))*(100/o):(this._max-t.value)*(100/(o+n)),{color:s||t.color,offset:h}})}getAreaMinMax(t,a){return(t+=` L ${this.coordsMax[this.coordsMax.length-1][X]},
                `+this.coordsMax[this.coordsMax.length-1][Y])+a+" z"}getArea(t){var a=(0<=this._min?this.height:this.height+0-Math.abs(this._min)/(this._max-this._min)*this.height)+1.5*this.drawArea.y;return(t+=` L ${this.coords[this.coords.length-1][X]+this.drawArea.x}, `+a)+` L ${this.coords[0][X]}, ${a} z`}polarToCartesian(t,a,i,s,r){r=(r-90)*Math.PI/180;return{x:t+i*Math.cos(r),y:a+s*Math.sin(r)}}_calcRadialBarcodeCoords(t,a,i,s,r,h){var e=this.drawArea.x+this.drawArea.width/2,o=this.drawArea.y+this.drawArea.height/2,n=this.polarToCartesian(e,o,s,r,a),d=this.polarToCartesian(e,o,s,r,t),l=Math.abs(a-t)<=180?"0":"1",i=i?"0":"1",s=s-h,r=r-h;return{start:n,end:d,start2:this.polarToCartesian(e,o,s,r,a),end2:this.polarToCartesian(e,o,s,r,t),largeArcFlag:l,sweepFlag:i}}_calcRadialBarcode(s,u=!1,m=4,t){var r=this._logarithmic?Math.log10(Math.max(1,this.max)):this.max;let _=this._logarithmic?Math.log10(Math.max(1,this.min)):this.min;var h=this.hours*this.points;let w=360/h;let p=0,x=(r-_)/this.radialBarcodeSize;var e=s.map(t=>{var a=u?this.max:t[V];let i,s;switch(this.config.sparkline.show?.chart_variant){case"sunburst":case"sunburst_centered":i=((this._logarithmic?Math.log10(Math.max(1,a)):a)-_)/x,s=(this.drawArea.width-this.radialBarcodeSize+i)/2;break;case"sunburst_outward":i=((this._logarithmic?Math.log10(Math.max(1,a)):a)-_)/x,s=this.drawArea.width/2-this.radialBarcodeSize+i;break;case"sunburst_inward":i=((this._logarithmic?Math.log10(Math.max(1,a)):a)-_)/x,s=this.drawArea.width/2;break;default:i=this.radialBarcodeSize,s=this.drawArea.width/2}var t=[],r=[],h=[],e=[],{start:o,end:n,start2:d,end2:l,largeArcFlag:c,sweepFlag:g}=this._calcRadialBarcodeCoords(p+m,p+w-m,!0,s,s,i);return p+=w,t.push(o.x,n.x,d.x,l.x),r.push(o.y,n.y,d.y,l.y),h.push(this.drawArea.width/2,this.drawArea.width/2-this.radialBarcodeSize),e.push(this.drawArea.height/2,this.drawArea.height/2-this.radialBarcodeSize),[t,r,a,0,h,e,c,g]});if(u&&s.length!==h){let a,i;var o=this.max;switch(this.config.sparkline.show?.chart_variant){case"sunburst":case"sunburst_centered":a=((this._logarithmic?Math.log10(Math.max(1,o)):o)-_)/x,i=(this.drawArea.width-this.radialBarcodeSize+a)/2;break;case"sunburst_outward":a=((this._logarithmic?Math.log10(Math.max(1,o)):o)-_)/x,i=this.drawArea.width/2-this.radialBarcodeSize+a;break;case"sunburst_inward":a=((this._logarithmic?Math.log10(Math.max(1,o)):o)-_)/x,i=this.drawArea.width/2;break;default:a=this.radialBarcodeSize,i=this.drawArea.width/2}var n=[];for(let t=s.length;t<h;t++){n[t]={},n[t][X]=t,n[t][Y]=0,n[t][V]=r;var d=[],l=[],c=[],g=[],{start:M,end:f,start2:A,end2:v,largeArcFlag:y,sweepFlag:b}=this._calcRadialBarcodeCoords(p+m,p+w-m,!0,i,i,a);p+=w,d.push(M.x,f.x,A.x,v.x),l.push(M.y,f.y,A.y,v.y),c.push(this.drawArea.width/2,this.drawArea.width/2-this.radialBarcodeSize),g.push(this.drawArea.height/2,this.drawArea.height/2-this.radialBarcodeSize),e.push([d,l,o,0,c,g,y,b])}}return e}getRadialBarcodeBackground(t,a,i=4,s=4){return this.backgroundCoords=[],this.backgroundCoords=[...this.coords],this._calcRadialBarcode(this.backgroundCoords,!0,i,s).map((t,a)=>({start:{x:t[X][0],y:t[Y][0]},end:{x:t[X][1],y:t[Y][1]},start2:{x:t[X][2],y:t[Y][2]},end2:{x:t[X][3],y:t[Y][3]},radius:{x:t[RX][0],y:t[RY][0]},radius2:{x:t[RX][1],y:t[RY][1]},largeArcFlag:t[6],sweepFlag:t[7],value:t[V]}))}getRadialBarcodeBackgroundPaths(){return this.radialBarcodeBackground.map((t,a)=>{let i,s,r,h,e="0";["flower2","flower","rice_grain"].includes(this.config.sparkline.show?.chart_viz)?(s="flower"===this.config.sparkline.show.chart_viz&&"sunburst_inward"===this.config.sparkline.show.chart_variant?(i=t.radius.x,t.radius.y):(n=Math.abs(t.start.x-t.end.x),o=Math.abs(t.start.y-t.end.y),i=Math.sqrt(n*n+o*o)/2),"flower"===this.config.sparkline.show.chart_viz&&"sunburst_outward"===this.config.sparkline.show.chart_variant?(r=t.radius2.x,h=t.radius2.y):(n=Math.abs(t.start2.x-t.end2.x),o=Math.abs(t.start2.y-t.end2.y),r=Math.sqrt(n*n+o*o)/2,h=r,e=["rice_grain","flower"].includes(this.config.sparkline.show.chart_viz)?"1":"0")):(i=t.radius.x,s=t.radius.y,r=t.radius2.x,h=t.radius2.y);var o,n=["M",t.start.x,t.start.y,"A",i,s,0,t.largeArcFlag,t.sweepFlag,t.end.x,t.end.y,"L",t.end2.x,t.end2.y,"A",r,h,0,t.largeArcFlag,t.sweepFlag===e?"1":"0",t.start2.x,t.start2.y,"Z"].join(" ");return n})}getRadialBarcode(t,a,i=4,s=4){return this._calcRadialBarcode(this.coords,!1,i,s).map((t,a)=>({start:{x:t[X][0],y:t[Y][0]},end:{x:t[X][1],y:t[Y][1]},start2:{x:t[X][2],y:t[Y][2]},end2:{x:t[X][3],y:t[Y][3]},radius:{x:t[RX][0],y:t[RY][0]},radius2:{x:t[RX][1],y:t[RY][1]},largeArcFlag:t[6],sweepFlag:t[7],value:t[V]}))}getRadialBarcodePaths(){return this.radialBarcode.map((t,a)=>{let i,s,r,h,e="0";["flower2","flower","rice_grain"].includes(this.config.sparkline.show?.chart_viz)?(s="flower"===this.config.sparkline.show.chart_viz&&"sunburst_inward"===this.config.sparkline.show.chart_variant?(i=t.radius.x,t.radius.y):(n=Math.abs(t.start.x-t.end.x),o=Math.abs(t.start.y-t.end.y),i=Math.sqrt(n*n+o*o)/2),"flower"===this.config.sparkline.show.chart_viz&&"sunburst_outward"===this.config.sparkline.show.chart_variant?(r=t.radius2.x,h=t.radius2.y):(n=Math.abs(t.start2.x-t.end2.x),o=Math.abs(t.start2.y-t.end2.y),r=Math.sqrt(n*n+o*o)/2,h=r,e=["rice_grain","flower"].includes(this.config.sparkline.show.chart_viz)?"1":"0")):(i=t.radius.x,s=t.radius.y,r=t.radius2.x,h=t.radius2.y);var o,n=["M",t.start.x,t.start.y,"A",i,s,0,t.largeArcFlag,t.sweepFlag,t.end.x,t.end.y,"L",t.end2.x,t.end2.y,"A",r,h,0,t.largeArcFlag,t.sweepFlag===e?"1":"0",t.start2.x,t.start2.y,"Z"].join(" ");return n})}getBarcode(i,s,r=4,t){var a=this._logarithmic?Math.log10(Math.max(1,this.max)):this.max;let h=this._logarithmic?Math.log10(Math.max(1,this.min)):this.min;var e=this.coords;let o=(this.drawArea.width+r)/Math.ceil(this.hours*this.points)/s,n=(a-h)/this.drawArea.height||1;switch(this.config.sparkline.show.chart_variant){case"audio":return e.map((t,a)=>({x:o*a*s+o*i+this.drawArea.x,y:this.drawArea.height/2-((this._logarithmic?Math.log10(Math.max(1,t[V])):t[V])-h)/n/2,height:((this._logarithmic?Math.log10(Math.max(1,t[V])):t[V])-h)/n,width:o-r/2,value:t[V]}));case"stalactites":return e.map((t,a)=>({x:o*a*s+o*i+this.drawArea.x,y:0,height:((this._logarithmic?Math.log10(Math.max(1,t[V])):t[V])-h)/n,width:o-r/2,value:t[V]}));case"stalagmites":return e.map((t,a)=>({x:o*a*s+o*i+this.drawArea.x,y:+this.drawArea.height-((this._logarithmic?Math.log10(Math.max(1,t[V])):t[V])-h)/n,height:((this._logarithmic?Math.log10(Math.max(1,t[V])):t[V])-h)/n,width:o-r/2,value:t[V]}));default:return e.map((t,a)=>({x:o*a*s+o*i+this.drawArea.x,y:0,height:this.drawArea.height,width:o-r/2,value:t[V]}))}}getEqualizer(i,s,r=4,t=4){let h=(this.drawArea.width+r)/Math.ceil(this.hours*this.points)/s;var a=(this._max-this._min)/this.drawArea.height||1;this._min<0&&Math.abs(this._min);let e=(this.drawArea.height-this.levelCount*t)/this.levelCount,o;return this.coords.map((t,a)=>{var i=[],s=Math.trunc(t[V]/this.valuesPerBucket),r=Math.trunc(this._min/this.valuesPerBucket);o=s-r,i[X]=t[X],i[Y]=[],i[V]=[];for(let t=0;t<o;t++)i[V][t]=this._min+t*this.valuesPerBucket;return i[Y]=this._calcLevelY(i),i}).map((t,a)=>({x:h*a*s+h*i+this.drawArea.x,y:t[Y],height:e,width:h-r,value:t[V]}))}getGrades(i,s,r=4,e=4){let h=(this.drawArea.width+r)/Math.ceil(this.hours*this.points)/s,o=(this.drawArea.height-(this.gradeRanks.length-1)*e)/this.gradeRanks.length,n;return this.coords.map((i,t)=>{var a=[],s=this.gradeRanks.length;n=+s,a[X]=i[X],a[Y]=[];let r=-1,h=0;a[V]=[];for(let a=0;a<n;a++){0;for(let t=h=0;t<this.gradeRanks[a].rangeMin.length;t++)i[V]>=this.gradeRanks[a].rangeMin[t]&&i[V]<this.gradeRanks[a].rangeMax[t]&&(h=t,r=a)}for(let t=0;t<=n;t++)t<=r&&(a[V][t]=this.gradeRanks[t].length>h?this.gradeRanks[t].rangeMin[h]:this.gradeRanks[t].rangeMin[0]),a[Y][t]=this.drawArea.height+this.margin.t-t*(o+e);return a}).map((t,a)=>({x:h*a*s+h*i+this.drawArea.x,y:t[Y],height:o,width:h-r,value:t[V]}))}getBars(i,s,r=4,t){var a=this._calcY(this.coords);let h=(this.drawArea.width+r)/Math.ceil(this.hours*this.points)/s,e=(this._max-this._min)/this.drawArea.height||1;this._min<0&&(Math.abs(this._min),e);return a.map((t,a)=>({x:h*a*s+h*i+this.drawArea.x,y:0<this._min?t[Y]:t[Y2],height:0<t[V]?this._min<0?t[V]/e:(t[V]-this._min)/e:t[Y]-t[Y2],width:h-r,value:t[V]}))}_midPoint(t,a,i,s){return[(t-i)/2+i,(a-s)/2+s]}_average(t){return t.reduce((t,a)=>t+parseFloat(a.state),0)/t.length}_median(t){var t=[...t].sort((t,a)=>parseFloat(t)-parseFloat(a)),a=Math.floor((t.length-1)/2);return t.length%2==1?parseFloat(t[a].state):(parseFloat(t[a].state)+parseFloat(t[a+1].state))/2}_maximum(t){return Math.max(...t.map(t=>t.state))}_minimum(t){return Math.min(...t.map(t=>t.state))}_first(t){return parseFloat(t[0].state)}_last(t){return parseFloat(t[t.length-1].state)}_sum(t){return t.reduce((t,a)=>t+parseFloat(a.state),0)}_delta(t){return this._maximum(t)-this._minimum(t)}_diff(t){return this._last(t)-this._first(t)}_lastValue(t){return!["delta","diff"].includes(this.aggregateFuncName)&&parseFloat(t[t.length-1].state)||0}_updateEndTime(){if(this._endTime=new Date,"calendar"===this.config.period.type)"day"===this.config.period.calendar.period&&0!==this.config.period.calendar.offset&&(this._endTime.setHours(0,0,0,0),this.hours=24);else switch(this._groupBy){case"month":this._endTime.setMonth(this._endTime.getMonth()+1),this._endTime.setDate(1);break;case"date":this._endTime.setDate(this._endTime.getDate()+1),this._endTime.setHours(0,0,0,0);break;case"hour":this._endTime.setHours(this._endTime.getHours()+1),this._endTime.setMinutes(0,0,0)}}}export{X,Y,V,Y2,RX,RY,L,T,R,B,ONE_HOUR};